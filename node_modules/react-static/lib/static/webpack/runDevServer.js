"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = runDevServer;
exports.reloadClientData = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _webpack = _interopRequireDefault(require("webpack"));

var _chalk = _interopRequireDefault(require("chalk"));

var _socket = _interopRequireDefault(require("socket.io"));

var _webpackDevServer = _interopRequireDefault(require("webpack-dev-server"));

var _makeWebpackConfig = _interopRequireDefault(require("./makeWebpackConfig"));

var _getRouteData = _interopRequireDefault(require("../getRouteData"));

var _plugins = _interopRequireDefault(require("../plugins"));

var _utils = require("../../utils");

var _fetchSiteData = _interopRequireDefault(require("../fetchSiteData"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var devServer;
var latestState;

var buildDevRoutes = function buildDevRoutes() {};

var reloadClientData = function reloadClientData() {
  if (reloadClientData.current) {
    reloadClientData.current();
  }
}; // Starts the development server


exports.reloadClientData = reloadClientData;

function runDevServer(_x) {
  return _runDevServer.apply(this, arguments);
}

function _runDevServer() {
  _runDevServer = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(state) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!devServer) {
              _context.next = 7;
              break;
            }

            _context.next = 3;
            return buildDevRoutes(state);

          case 3:
            _context.next = 5;
            return reloadClientData();

          case 5:
            _context.next = 10;
            break;

          case 7:
            _context.next = 9;
            return runExpressServer(state);

          case 9:
            state = _context.sent;

          case 10:
            return _context.abrupt("return", state);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _runDevServer.apply(this, arguments);
}

function runExpressServer(_x2) {
  return _runExpressServer.apply(this, arguments);
}

function _runExpressServer() {
  _runExpressServer = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee6(state) {
    var intendedPort, port, defaultMessagePort, messagePort, messageHost, devConfig, devCompiler, devServerConfig, first, startedAt, skipLog, socket;
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            // Default to localhost:3000, or use a custom combo if defined in static.config.js
            // or environment variables
            intendedPort = Number(state.config.devServer.port);
            _context6.next = 3;
            return (0, _utils.findAvailablePort)(intendedPort);

          case 3:
            port = _context6.sent;
            defaultMessagePort = 4000;

            if (process.env.REACT_STATIC_MESSAGE_SOCKET_PORT) {
              defaultMessagePort = process.env.REACT_STATIC_MESSAGE_SOCKET_PORT;
            } // Find an available port for messages, as long as it's not the devServer port


            _context6.next = 8;
            return (0, _utils.findAvailablePort)(defaultMessagePort, [port]);

          case 8:
            messagePort = _context6.sent;
            messageHost = process.env.REACT_STATIC_MESSAGE_SOCKET_HOST || 'http://localhost';

            if (intendedPort !== port) {
              console.log(_chalk["default"].red("Warning! Port ".concat(intendedPort, " is not available. Using port ").concat(_chalk["default"].green(port), " instead!")));
            }

            state = _objectSpread({}, state, {
              config: _objectSpread({}, state.config, {
                devServer: _objectSpread({}, state.config.devServer, {
                  port: port
                })
              })
            });
            devConfig = (0, _makeWebpackConfig["default"])(state);
            devCompiler = (0, _webpack["default"])(devConfig);
            devServerConfig = _objectSpread({
              contentBase: [state.config.paths.PUBLIC, state.config.paths.DIST],
              publicPath: '/',
              historyApiFallback: true,
              compress: false,
              clientLogLevel: 'warning',
              overlay: true,
              stats: 'errors-only',
              noInfo: true
            }, state.config.devServer, {
              hotOnly: true,
              proxy: _objectSpread({
                '/socket.io': {
                  target: "".concat(messageHost, ":").concat(messagePort),
                  ws: true
                }
              }, state.config.devServer ? state.config.devServer.proxy || {} : {}),
              watchOptions: _objectSpread({}, state.config.devServer ? state.config.devServer.watchOptions || {} : {}, {
                ignored: [/node_modules/].concat((0, _toConsumableArray2["default"])((state.config.devServer.watchOptions || {}).ignored || []))
              }),
              before: function before(app) {
                // Since routes may change during dev, this function can rebuild all of the config
                // routes. It also references the original config when possible, to make sure it
                // uses any up to date getData callback generated from new or replacement routes.
                buildDevRoutes =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4(newState) {
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return (0, _fetchSiteData["default"])(newState);

                          case 2:
                            latestState = _context4.sent;
                            app.get('/__react-static__/siteData',
                            /*#__PURE__*/
                            function () {
                              var _ref2 = (0, _asyncToGenerator2["default"])(
                              /*#__PURE__*/
                              _regenerator["default"].mark(function _callee2(req, res, next) {
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                  while (1) {
                                    switch (_context2.prev = _context2.next) {
                                      case 0:
                                        try {
                                          res.send(latestState.siteData);
                                        } catch (err) {
                                          res.status(500);
                                          res.send(err);
                                          next(err);
                                        }

                                      case 1:
                                      case "end":
                                        return _context2.stop();
                                    }
                                  }
                                }, _callee2);
                              }));

                              return function (_x4, _x5, _x6) {
                                return _ref2.apply(this, arguments);
                              };
                            }()); // Serve each routes data

                            latestState.routes.forEach(function (_ref3) {
                              var routePath = _ref3.path;
                              app.get("/__react-static__/routeInfo/".concat(encodeURI(routePath === '/' ? '' : routePath)),
                              /*#__PURE__*/
                              function () {
                                var _ref4 = (0, _asyncToGenerator2["default"])(
                                /*#__PURE__*/
                                _regenerator["default"].mark(function _callee3(req, res, next) {
                                  var route, err;
                                  return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                      switch (_context3.prev = _context3.next) {
                                        case 0:
                                          // Make sure we have the most up to date route from the config, not
                                          // an out of date object.
                                          route = latestState.routes.find(function (d) {
                                            return d.path === routePath;
                                          });
                                          _context3.prev = 1;

                                          if (route) {
                                            _context3.next = 6;
                                            break;
                                          }

                                          err = new Error("Route could not be found for: ".concat(routePath, "\n\nIf you removed this route, disregard this error.\nIf this is a dynamic route, consider adding it to the prefetchExcludes list:\n\n  addPrefetchExcludes(['").concat(routePath, "'])\n"));
                                          delete err.stack;
                                          throw err;

                                        case 6:
                                          _context3.next = 8;
                                          return (0, _getRouteData["default"])(route, latestState);

                                        case 8:
                                          route = _context3.sent;
                                          // Don't use any hashProp, just pass all the data in dev
                                          res.json(route);
                                          _context3.next = 16;
                                          break;

                                        case 12:
                                          _context3.prev = 12;
                                          _context3.t0 = _context3["catch"](1);
                                          res.status(404);
                                          next(_context3.t0);

                                        case 16:
                                        case "end":
                                          return _context3.stop();
                                      }
                                    }
                                  }, _callee3, null, [[1, 12]]);
                                }));

                                return function (_x7, _x8, _x9) {
                                  return _ref4.apply(this, arguments);
                                };
                              }());
                            });
                            return _context4.abrupt("return", new Promise(function (resolve) {
                              return setTimeout(resolve, 1);
                            }));

                          case 6:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function buildDevRoutes(_x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                buildDevRoutes(state);

                if (state.config.devServer && state.config.devServer.before) {
                  state.config.devServer.before(app);
                }

                return app;
              }
            });
            first = true;
            startedAt = Date.now();
            skipLog = false;
            console.log('Bundling Application...');
            (0, _utils.time)(_chalk["default"].green("[\u2713] Application Bundled"));
            devCompiler.hooks.invalid.tap({
              name: 'React-Static'
            }, function (file, changed) {
              // If a file is changed within the first two seconds of
              // the server starting, we don't bark about it. Less
              // noise is better!
              skipLog = changed - startedAt < 2000;

              if (!skipLog) {
                console.log('File changed:', file.replace(state.config.paths.ROOT, ''));
                console.log('Updating bundle...');
                (0, _utils.time)(_chalk["default"].green("[\u2713] Bundle Updated"));
              }
            });
            devCompiler.hooks.done.tap({
              name: 'React-Static'
            }, function (stats) {
              var messages = stats.toJson({}, true);
              var isSuccessful = !messages.errors.length;
              var hasWarnings = messages.warnings.length;

              if (isSuccessful && !skipLog) {
                if (first) {
                  // Print out any dev compiler warnings
                  if (hasWarnings) {
                    console.log(_chalk["default"].yellowBright("\n[!] There were ".concat(messages.warnings.length, " warnings during compilation\n")));
                    messages.warnings.forEach(function (message, index) {
                      console.warn("[warning ".concat(index, "]: ").concat(message, "\n"));
                    });
                  }

                  (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] Application Bundled"));
                  var protocol = state.config.devServer.https ? 'https' : 'http';
                  console.log("".concat(_chalk["default"].green("[\u2713] App serving at"), " ").concat(_chalk["default"].blue("".concat(protocol, "://").concat(state.config.devServer.host, ":").concat(state.config.devServer.port))));
                } else {
                  (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] Bundle Updated"));
                }
              } else if (!skipLog) {
                console.log(_chalk["default"].redBright("[\u274C] Application bundling failed"));
                console.error(_chalk["default"].redBright(messages.errors.join('\n')));
                console.warn(_chalk["default"].yellowBright(messages.warnings.join('\n')));
              }

              first = false;
            }); // Start the webpack dev server

            devServer = new _webpackDevServer["default"](devCompiler, devServerConfig); // Start the messages socket

            socket = (0, _socket["default"])();
            reloadClientData.current =
            /*#__PURE__*/
            (0, _asyncToGenerator2["default"])(
            /*#__PURE__*/
            _regenerator["default"].mark(function _callee5() {
              return _regenerator["default"].wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return (0, _fetchSiteData["default"])(latestState);

                    case 2:
                      latestState = _context5.sent;
                      socket.emit('message', {
                        type: 'reloadClientData'
                      });

                    case 4:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }));
            _context6.next = 27;
            return new Promise(function (resolve, reject) {
              devServer.listen(port, null, function (err) {
                if (err) {
                  console.error("Listening on ".concat(port, " failed: ").concat(err));
                  return reject(err);
                }

                resolve();
              });
            });

          case 27:
            // Make sure we start listening on the message port after the dev server.
            // We do this mostly to appease codesandbox.io, since they autobind to the first
            // port that opens up for their preview window.
            socket.listen(messagePort);
            console.log('Running plugins...');
            _context6.next = 31;
            return _plugins["default"].afterDevServerStart(state);

          case 31:
            state = _context6.sent;
            return _context6.abrupt("return", state);

          case 33:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _runExpressServer.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdGF0aWMvd2VicGFjay9ydW5EZXZTZXJ2ZXIuanMiXSwibmFtZXMiOlsiZGV2U2VydmVyIiwibGF0ZXN0U3RhdGUiLCJidWlsZERldlJvdXRlcyIsInJlbG9hZENsaWVudERhdGEiLCJjdXJyZW50IiwicnVuRGV2U2VydmVyIiwic3RhdGUiLCJydW5FeHByZXNzU2VydmVyIiwiaW50ZW5kZWRQb3J0IiwiTnVtYmVyIiwiY29uZmlnIiwicG9ydCIsImRlZmF1bHRNZXNzYWdlUG9ydCIsInByb2Nlc3MiLCJlbnYiLCJSRUFDVF9TVEFUSUNfTUVTU0FHRV9TT0NLRVRfUE9SVCIsIm1lc3NhZ2VQb3J0IiwibWVzc2FnZUhvc3QiLCJSRUFDVF9TVEFUSUNfTUVTU0FHRV9TT0NLRVRfSE9TVCIsImNvbnNvbGUiLCJsb2ciLCJjaGFsayIsInJlZCIsImdyZWVuIiwiZGV2Q29uZmlnIiwiZGV2Q29tcGlsZXIiLCJkZXZTZXJ2ZXJDb25maWciLCJjb250ZW50QmFzZSIsInBhdGhzIiwiUFVCTElDIiwiRElTVCIsInB1YmxpY1BhdGgiLCJoaXN0b3J5QXBpRmFsbGJhY2siLCJjb21wcmVzcyIsImNsaWVudExvZ0xldmVsIiwib3ZlcmxheSIsInN0YXRzIiwibm9JbmZvIiwiaG90T25seSIsInByb3h5IiwidGFyZ2V0Iiwid3MiLCJ3YXRjaE9wdGlvbnMiLCJpZ25vcmVkIiwiYmVmb3JlIiwiYXBwIiwibmV3U3RhdGUiLCJnZXQiLCJyZXEiLCJyZXMiLCJuZXh0Iiwic2VuZCIsInNpdGVEYXRhIiwiZXJyIiwic3RhdHVzIiwicm91dGVzIiwiZm9yRWFjaCIsInJvdXRlUGF0aCIsInBhdGgiLCJlbmNvZGVVUkkiLCJyb3V0ZSIsImZpbmQiLCJkIiwiRXJyb3IiLCJzdGFjayIsImpzb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJmaXJzdCIsInN0YXJ0ZWRBdCIsIkRhdGUiLCJub3ciLCJza2lwTG9nIiwiaG9va3MiLCJpbnZhbGlkIiwidGFwIiwibmFtZSIsImZpbGUiLCJjaGFuZ2VkIiwicmVwbGFjZSIsIlJPT1QiLCJkb25lIiwibWVzc2FnZXMiLCJ0b0pzb24iLCJpc1N1Y2Nlc3NmdWwiLCJlcnJvcnMiLCJsZW5ndGgiLCJoYXNXYXJuaW5ncyIsIndhcm5pbmdzIiwieWVsbG93QnJpZ2h0IiwibWVzc2FnZSIsImluZGV4Iiwid2FybiIsInByb3RvY29sIiwiaHR0cHMiLCJibHVlIiwiaG9zdCIsInJlZEJyaWdodCIsImVycm9yIiwiam9pbiIsIldlYnBhY2tEZXZTZXJ2ZXIiLCJzb2NrZXQiLCJlbWl0IiwidHlwZSIsInJlamVjdCIsImxpc3RlbiIsInBsdWdpbnMiLCJhZnRlckRldlNlcnZlclN0YXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBSUEsU0FBSjtBQUNBLElBQUlDLFdBQUo7O0FBQ0EsSUFBSUMsY0FBYyxHQUFHLDBCQUFNLENBQUUsQ0FBN0I7O0FBRU8sSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixHQUFNO0FBQ3BDLE1BQUlBLGdCQUFnQixDQUFDQyxPQUFyQixFQUE4QjtBQUM1QkQsSUFBQUEsZ0JBQWdCLENBQUNDLE9BQWpCO0FBQ0Q7QUFDRixDQUpNLEMsQ0FNUDs7Ozs7U0FDOEJDLFk7Ozs7Ozs7K0JBQWYsaUJBQTRCQyxLQUE1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBT1ROLFNBUFM7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkFRTEUsY0FBYyxDQUFDSSxLQUFELENBUlQ7O0FBQUE7QUFBQTtBQUFBLG1CQVNMSCxnQkFBZ0IsRUFUWDs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLG1CQVdHSSxnQkFBZ0IsQ0FBQ0QsS0FBRCxDQVhuQjs7QUFBQTtBQVdYQSxZQUFBQSxLQVhXOztBQUFBO0FBQUEsNkNBY05BLEtBZE07O0FB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LFVBQUEwQyxHQUFHLEVBQUk7QUFDbEMsb0JBQUlBLEdBQUosRUFBUztBQUNQbEMsa0JBQUFBLE9BQU8sQ0FBQ2dGLEtBQVIsd0JBQThCeEYsSUFBOUIsc0JBQThDMEMsR0FBOUM7QUFDQSx5QkFBT29ELE1BQU0sQ0FBQ3BELEdBQUQsQ0FBYjtBQUNEOztBQUNEYyxnQkFBQUEsT0FBTztBQUNSLGVBTkQ7QUFPRCxhQVJLLENBck5SOztBQUFBO0FBK05FO0FBQ0E7QUFDQTtBQUNBbUMsWUFBQUEsTUFBTSxDQUFDSSxNQUFQLENBQWMxRixXQUFkO0FBRUFHLFlBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLG9CQUFaO0FBcE9GO0FBQUEsbUJBcU9nQnVGLG9CQUFRQyxtQkFBUixDQUE0QnRHLEtBQTVCLENBck9oQjs7QUFBQTtBQXFPRUEsWUFBQUEsS0FyT0Y7QUFBQSw4Q0F1T1NBLEtBdk9UOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEciLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlLCByZWFjdC9uby1kYW5nZXIsIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHMgKi9cbmltcG9ydCB3ZWJwYWNrIGZyb20gJ3dlYnBhY2snXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnXG5pbXBvcnQgaW8gZnJvbSAnc29ja2V0LmlvJ1xuaW1wb3J0IFdlYnBhY2tEZXZTZXJ2ZXIgZnJvbSAnd2VicGFjay1kZXYtc2VydmVyJ1xuLy9cbmltcG9ydCBtYWtlV2VicGFja0NvbmZpZyBmcm9tICcuL21ha2VXZWJwYWNrQ29uZmlnJ1xuaW1wb3J0IGdldFJvdXRlRGF0YSBmcm9tICcuLi9nZXRSb3V0ZURhdGEnXG5pbXBvcnQgcGx1Z2lucyBmcm9tICcuLi9wbHVnaW5zJ1xuaW1wb3J0IHsgZmluZEF2YWlsYWJsZVBvcnQsIHRpbWUsIHRpbWVFbmQgfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCBmZXRjaFNpdGVEYXRhIGZyb20gJy4uL2ZldGNoU2l0ZURhdGEnXG5cbmxldCBkZXZTZXJ2ZXJcbmxldCBsYXRlc3RTdGF0ZVxubGV0IGJ1aWxkRGV2Um91dGVzID0gKCkgPT4ge31cblxuZXhwb3J0IGNvbnN0IHJlbG9hZENsaWVudERhdGEgPSAoKSA9PiB7XG4gIGlmIChyZWxvYWRDbGllbnREYXRhLmN1cnJlbnQpIHtcbiAgICByZWxvYWRDbGllbnREYXRhLmN1cnJlbnQoKVxuICB9XG59XG5cbi8vIFN0YXJ0cyB0aGUgZGV2ZWxvcG1lbnQgc2VydmVyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBydW5EZXZTZXJ2ZXIoc3RhdGUpIHtcbiAgLy8gVE9ETyBjaGVjayBjb25maWcuZGV2U2VydmVyIGZvciBjaGFuZ2VzIGFuZCBub3RpZnkgdXNlclxuICAvLyBpZiB0aGUgc2VydmVyIG5lZWRzIHRvIGJlIHJlc3RhcnRlZCBmb3IgY2hhbmdlcyB0byB0YWtlXG4gIC8vIGVmZmVjdC5cblxuICAvLyBJZiB0aGUgc2VydmVyIGlzIGFscmVhZHkgcnVubmluZywgdHJpZ2dlciBhIHJlZnJlc2ggdG8gdGhlIGNsaWVudFxuXG4gIGlmIChkZXZTZXJ2ZXIpIHtcbiAgICBhd2FpdCBidWlsZERldlJvdXRlcyhzdGF0ZSlcbiAgICBhd2FpdCByZWxvYWRDbGllbnREYXRhKClcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IGF3YWl0IHJ1bkV4cHJlc3NTZXJ2ZXIoc3RhdGUpXG4gIH1cblxuICByZXR1cm4gc3RhdGVcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuRXhwcmVzc1NlcnZlcihzdGF0ZSkge1xuICAvLyBEZWZhdWx0IHRvIGxvY2FsaG9zdDozMDAwLCBvciB1c2UgYSBjdXN0b20gY29tYm8gaWYgZGVmaW5lZCBpbiBzdGF0aWMuY29uZmlnLmpzXG4gIC8vIG9yIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICBjb25zdCBpbnRlbmRlZFBvcnQgPSBOdW1iZXIoc3RhdGUuY29uZmlnLmRldlNlcnZlci5wb3J0KVxuICBjb25zdCBwb3J0ID0gYXdhaXQgZmluZEF2YWlsYWJsZVBvcnQoaW50ZW5kZWRQb3J0KVxuXG4gIGxldCBkZWZhdWx0TWVzc2FnZVBvcnQgPSA0MDAwXG5cbiAgaWYgKHByb2Nlc3MuZW52LlJFQUNUX1NUQVRJQ19NRVNTQUdFX1NPQ0tFVF9QT1JUKSB7XG4gICAgZGVmYXVsdE1lc3NhZ2VQb3J0ID0gcHJvY2Vzcy5lbnYuUkVBQ1RfU1RBVElDX01FU1NBR0VfU09DS0VUX1BPUlRcbiAgfVxuICAvLyBGaW5kIGFuIGF2YWlsYWJsZSBwb3J0IGZvciBtZXNzYWdlcywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGUgZGV2U2VydmVyIHBvcnRcbiAgY29uc3QgbWVzc2FnZVBvcnQgPSBhd2FpdCBmaW5kQXZhaWxhYmxlUG9ydChkZWZhdWx0TWVzc2FnZVBvcnQsIFtwb3J0XSlcblxuICBjb25zdCBtZXNzYWdlSG9zdCA9XG4gICAgcHJvY2Vzcy5lbnYuUkVBQ1RfU1RBVElDX01FU1NBR0VfU09DS0VUX0hPU1QgfHwgJ2h0dHA6Ly9sb2NhbGhvc3QnXG5cbiAgaWYgKGludGVuZGVkUG9ydCAhPT0gcG9ydCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgY2hhbGsucmVkKFxuICAgICAgICBgV2FybmluZyEgUG9ydCAke2ludGVuZGVkUG9ydH0gaXMgbm90IGF2YWlsYWJsZS4gVXNpbmcgcG9ydCAke2NoYWxrLmdyZWVuKFxuICAgICAgICAgIHBvcnRcbiAgICAgICAgKX0gaW5zdGVhZCFgXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgc3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgY29uZmlnOiB7XG4gICAgICAuLi5zdGF0ZS5jb25maWcsXG4gICAgICBkZXZTZXJ2ZXI6IHtcbiAgICAgICAgLi4uc3RhdGUuY29uZmlnLmRldlNlcnZlcixcbiAgICAgICAgcG9ydCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfVxuXG4gIGNvbnN0IGRldkNvbmZpZyA9IG1ha2VXZWJwYWNrQ29uZmlnKHN0YXRlKVxuICBjb25zdCBkZXZDb21waWxlciA9IHdlYnBhY2soZGV2Q29uZmlnKVxuXG4gIGNvbnN0IGRldlNlcnZlckNvbmZpZyA9IHtcbiAgICBjb250ZW50QmFzZTogW3N0YXRlLmNvbmZpZy5wYXRocy5QVUJMSUMsIHN0YXRlLmNvbmZpZy5wYXRocy5ESVNUXSxcbiAgICBwdWJsaWNQYXRoOiAnLycsXG4gICAgaGlzdG9yeUFwaUZhbGxiYWNrOiB0cnVlLFxuICAgIGNvbXByZXNzOiBmYWxzZSxcbiAgICBjbGllbnRMb2dMZXZlbDogJ3dhcm5pbmcnLFxuICAgIG92ZXJsYXk6IHRydWUsXG4gICAgc3RhdHM6ICdlcnJvcnMtb25seScsXG4gICAgbm9JbmZvOiB0cnVlLFxuICAgIC4uLnN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIsXG4gICAgaG90T25seTogdHJ1ZSxcbiAgICBwcm94eToge1xuICAgICAgJy9zb2NrZXQuaW8nOiB7XG4gICAgICAgIHRhcmdldDogYCR7bWVzc2FnZUhvc3R9OiR7bWVzc2FnZVBvcnR9YCxcbiAgICAgICAgd3M6IHRydWUsXG4gICAgICB9LFxuICAgICAgLi4uKHN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIgPyBzdGF0ZS5jb25maWcuZGV2U2VydmVyLnByb3h5IHx8IHt9IDoge30pLFxuICAgIH0sXG4gICAgd2F0Y2hPcHRpb25zOiB7XG4gICAgICAuLi4oc3RhdGUuY29uZmlnLmRldlNlcnZlclxuICAgICAgICA/IHN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIud2F0Y2hPcHRpb25zIHx8IHt9XG4gICAgICAgIDoge30pLFxuICAgICAgaWdub3JlZDogW1xuICAgICAgICAvbm9kZV9tb2R1bGVzLyxcblxuICAgICAgICAuLi4oKHN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIud2F0Y2hPcHRpb25zIHx8IHt9KS5pZ25vcmVkIHx8IFtdKSxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBiZWZvcmU6IGFwcCA9PiB7XG4gICAgICAvLyBTaW5jZSByb3V0ZXMgbWF5IGNoYW5nZSBkdXJpbmcgZGV2LCB0aGlzIGZ1bmN0aW9uIGNhbiByZWJ1aWxkIGFsbCBvZiB0aGUgY29uZmlnXG4gICAgICAvLyByb3V0ZXMuIEl0IGFsc28gcmVmZXJlbmNlcyB0aGUgb3JpZ2luYWwgY29uZmlnIHdoZW4gcG9zc2libGUsIHRvIG1ha2Ugc3VyZSBpdFxuICAgICAgLy8gdXNlcyBhbnkgdXAgdG8gZGF0ZSBnZXREYXRhIGNhbGxiYWNrIGdlbmVyYXRlZCBmcm9tIG5ldyBvciByZXBsYWNlbWVudCByb3V0ZXMuXG4gICAgICBidWlsZERldlJvdXRlcyA9IGFzeW5jIG5ld1N0YXRlID0+IHtcbiAgICAgICAgbGF0ZXN0U3RhdGUgPSBhd2FpdCBmZXRjaFNpdGVEYXRhKG5ld1N0YXRlKVxuXG4gICAgICAgIGFwcC5nZXQoJy9fX3JlYWN0LXN0YXRpY19fL3NpdGVEYXRhJywgYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcy5zZW5kKGxhdGVzdFN0YXRlLnNpdGVEYXRhKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzLnN0YXR1cyg1MDApXG4gICAgICAgICAgICByZXMuc2VuZChlcnIpXG4gICAgICAgICAgICBuZXh0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gU2VydmUgZWFjaCByb3V0ZXMgZGF0YVxuICAgICAgICBsYXRlc3RTdGF0ZS5yb3V0ZXMuZm9yRWFjaCgoeyBwYXRoOiByb3V0ZVBhdGggfSkgPT4ge1xuICAgICAgICAgIGFwcC5nZXQoXG4gICAgICAgICAgICBgL19fcmVhY3Qtc3RhdGljX18vcm91dGVJbmZvLyR7ZW5jb2RlVVJJKFxuICAgICAgICAgICAgICByb3V0ZVBhdGggPT09ICcvJyA/ICcnIDogcm91dGVQYXRoXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgICBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgdGhlIG1vc3QgdXAgdG8gZGF0ZSByb3V0ZSBmcm9tIHRoZSBjb25maWcsIG5vdFxuICAgICAgICAgICAgICAvLyBhbiBvdXQgb2YgZGF0ZSBvYmplY3QuXG4gICAgICAgICAgICAgIGxldCByb3V0ZSA9IGxhdGVzdFN0YXRlLnJvdXRlcy5maW5kKGQgPT4gZC5wYXRoID09PSByb3V0ZVBhdGgpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgUm91dGUgY291bGQgbm90IGJlIGZvdW5kIGZvcjogJHtyb3V0ZVBhdGh9XG5cbklmIHlvdSByZW1vdmVkIHRoaXMgcm91dGUsIGRpc3JlZ2FyZCB0aGlzIGVycm9yLlxuSWYgdGhpcyBpcyBhIGR5bmFtaWMgcm91dGUsIGNvbnNpZGVyIGFkZGluZyBpdCB0byB0aGUgcHJlZmV0Y2hFeGNsdWRlcyBsaXN0OlxuXG4gIGFkZFByZWZldGNoRXhjbHVkZXMoWycke3JvdXRlUGF0aH0nXSlcbmBcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlcnIuc3RhY2tcbiAgICAgICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdXRlID0gYXdhaXQgZ2V0Um91dGVEYXRhKHJvdXRlLCBsYXRlc3RTdGF0ZSlcblxuICAgICAgICAgICAgICAgIC8vIERvbid0IHVzZSBhbnkgaGFzaFByb3AsIGp1c3QgcGFzcyBhbGwgdGhlIGRhdGEgaW4gZGV2XG4gICAgICAgICAgICAgICAgcmVzLmpzb24ocm91dGUpXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoNDA0KVxuICAgICAgICAgICAgICAgIG5leHQoZXJyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEpKVxuICAgICAgfVxuXG4gICAgICBidWlsZERldlJvdXRlcyhzdGF0ZSlcblxuICAgICAgaWYgKHN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIgJiYgc3RhdGUuY29uZmlnLmRldlNlcnZlci5iZWZvcmUpIHtcbiAgICAgICAgc3RhdGUuY29uZmlnLmRldlNlcnZlci5iZWZvcmUoYXBwKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwXG4gICAgfSxcbiAgfVxuXG4gIGxldCBmaXJzdCA9IHRydWVcbiAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKVxuICBsZXQgc2tpcExvZyA9IGZhbHNlXG5cbiAgY29uc29sZS5sb2coJ0J1bmRsaW5nIEFwcGxpY2F0aW9uLi4uJylcbiAgdGltZShjaGFsay5ncmVlbignW1xcdTI3MTNdIEFwcGxpY2F0aW9uIEJ1bmRsZWQnKSlcblxuICBkZXZDb21waWxlci5ob29rcy5pbnZhbGlkLnRhcChcbiAgICB7XG4gICAgICBuYW1lOiAnUmVhY3QtU3RhdGljJyxcbiAgICB9LFxuICAgIChmaWxlLCBjaGFuZ2VkKSA9PiB7XG4gICAgICAvLyBJZiBhIGZpbGUgaXMgY2hhbmdlZCB3aXRoaW4gdGhlIGZpcnN0IHR3byBzZWNvbmRzIG9mXG4gICAgICAvLyB0aGUgc2VydmVyIHN0YXJ0aW5nLCB3ZSBkb24ndCBiYXJrIGFib3V0IGl0LiBMZXNzXG4gICAgICAvLyBub2lzZSBpcyBiZXR0ZXIhXG4gICAgICBza2lwTG9nID0gY2hhbmdlZCAtIHN0YXJ0ZWRBdCA8IDIwMDBcbiAgICAgIGlmICghc2tpcExvZykge1xuICAgICAgICBjb25zb2xlLmxvZygnRmlsZSBjaGFuZ2VkOicsIGZpbGUucmVwbGFjZShzdGF0ZS5jb25maWcucGF0aHMuUk9PVCwgJycpKVxuICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgYnVuZGxlLi4uJylcbiAgICAgICAgdGltZShjaGFsay5ncmVlbignW1xcdTI3MTNdIEJ1bmRsZSBVcGRhdGVkJykpXG4gICAgICB9XG4gICAgfVxuICApXG5cbiAgZGV2Q29tcGlsZXIuaG9va3MuZG9uZS50YXAoXG4gICAge1xuICAgICAgbmFtZTogJ1JlYWN0LVN0YXRpYycsXG4gICAgfSxcbiAgICBzdGF0cyA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IHN0YXRzLnRvSnNvbih7fSwgdHJ1ZSlcbiAgICAgIGNvbnN0IGlzU3VjY2Vzc2Z1bCA9ICFtZXNzYWdlcy5lcnJvcnMubGVuZ3RoXG4gICAgICBjb25zdCBoYXNXYXJuaW5ncyA9IG1lc3NhZ2VzLndhcm5pbmdzLmxlbmd0aFxuXG4gICAgICBpZiAoaXNTdWNjZXNzZnVsICYmICFza2lwTG9nKSB7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIC8vIFByaW50IG91dCBhbnkgZGV2IGNvbXBpbGVyIHdhcm5pbmdzXG4gICAgICAgICAgaWYgKGhhc1dhcm5pbmdzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgY2hhbGsueWVsbG93QnJpZ2h0KFxuICAgICAgICAgICAgICAgIGBcXG5bXFx1MDAyMV0gVGhlcmUgd2VyZSAke21lc3NhZ2VzLndhcm5pbmdzLmxlbmd0aH0gd2FybmluZ3MgZHVyaW5nIGNvbXBpbGF0aW9uXFxuYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBtZXNzYWdlcy53YXJuaW5ncy5mb3JFYWNoKChtZXNzYWdlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFt3YXJuaW5nICR7aW5kZXh9XTogJHttZXNzYWdlfVxcbmApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWVFbmQoY2hhbGsuZ3JlZW4oJ1tcXHUyNzEzXSBBcHBsaWNhdGlvbiBCdW5kbGVkJykpXG4gICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBzdGF0ZS5jb25maWcuZGV2U2VydmVyLmh0dHBzID8gJ2h0dHBzJyA6ICdodHRwJ1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCR7Y2hhbGsuZ3JlZW4oJ1tcXHUyNzEzXSBBcHAgc2VydmluZyBhdCcpfSAke2NoYWxrLmJsdWUoXG4gICAgICAgICAgICAgIGAke3Byb3RvY29sfTovLyR7c3RhdGUuY29uZmlnLmRldlNlcnZlci5ob3N0fToke3N0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIucG9ydH1gXG4gICAgICAgICAgICApfWBcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZUVuZChjaGFsay5ncmVlbignW1xcdTI3MTNdIEJ1bmRsZSBVcGRhdGVkJykpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNraXBMb2cpIHtcbiAgICAgICAgY29uc29sZS5sb2coY2hhbGsucmVkQnJpZ2h0KCdbXFx1Mjc0Q10gQXBwbGljYXRpb24gYnVuZGxpbmcgZmFpbGVkJykpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY2hhbGsucmVkQnJpZ2h0KG1lc3NhZ2VzLmVycm9ycy5qb2luKCdcXG4nKSkpXG4gICAgICAgIGNvbnNvbGUud2FybihjaGFsay55ZWxsb3dCcmlnaHQobWVzc2FnZXMud2FybmluZ3Muam9pbignXFxuJykpKVxuICAgICAgfVxuXG4gICAgICBmaXJzdCA9IGZhbHNlXG4gICAgfVxuICApXG5cbiAgLy8gU3RhcnQgdGhlIHdlYnBhY2sgZGV2IHNlcnZlclxuICBkZXZTZXJ2ZXIgPSBuZXcgV2VicGFja0RldlNlcnZlcihkZXZDb21waWxlciwgZGV2U2VydmVyQ29uZmlnKVxuXG4gIC8vIFN0YXJ0IHRoZSBtZXNzYWdlcyBzb2NrZXRcbiAgY29uc3Qgc29ja2V0ID0gaW8oKVxuXG4gIHJlbG9hZENsaWVudERhdGEuY3VycmVudCA9IGFzeW5jICgpID0+IHtcbiAgICBsYXRlc3RTdGF0ZSA9IGF3YWl0IGZldGNoU2l0ZURhdGEobGF0ZXN0U3RhdGUpXG4gICAgc29ja2V0LmVtaXQoJ21lc3NhZ2UnLCB7IHR5cGU6ICdyZWxvYWRDbGllbnREYXRhJyB9KVxuICB9XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGRldlNlcnZlci5saXN0ZW4ocG9ydCwgbnVsbCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgTGlzdGVuaW5nIG9uICR7cG9ydH0gZmFpbGVkOiAke2Vycn1gKVxuICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gIH0pXG5cbiAgLy8gTWFrZSBzdXJlIHdlIHN0YXJ0IGxpc3RlbmluZyBvbiB0aGUgbWVzc2FnZSBwb3J0IGFmdGVyIHRoZSBkZXYgc2VydmVyLlxuICAvLyBXZSBkbyB0aGlzIG1vc3RseSB0byBhcHBlYXNlIGNvZGVzYW5kYm94LmlvLCBzaW5jZSB0aGV5IGF1dG9iaW5kIHRvIHRoZSBmaXJzdFxuICAvLyBwb3J0IHRoYXQgb3BlbnMgdXAgZm9yIHRoZWlyIHByZXZpZXcgd2luZG93LlxuICBzb2NrZXQubGlzdGVuKG1lc3NhZ2VQb3J0KVxuXG4gIGNvbnNvbGUubG9nKCdSdW5uaW5nIHBsdWdpbnMuLi4nKVxuICBzdGF0ZSA9IGF3YWl0IHBsdWdpbnMuYWZ0ZXJEZXZTZXJ2ZXJTdGFydChzdGF0ZSlcblxuICByZXR1cm4gc3RhdGVcbn1cbiJdfQ==